
Using Tox with the Hudson Integration Server
=================================================


Integrating "sphinx" documentation checks in a Hudson job
----------------------------------------------------------------

If you are using a multi-configuration Hudson job which collects
JUnit Test results you will run into problems using the previous
method of running the sphinx-build command because it will not
generate JUnit results.  To accomodate this issue one solution
is to have ``py.test`` wrap the sphinx-checks and create a 
JUnit result file which wraps the result of calling sphinx-build. 
Here is an example: 

1. create a ``docs`` environment in your ``tox.ini`` file like this::

    [testenv:docs]
    basepython=python
    changedir=doc # or whereever you keep your sphinx-docs 
    deps=sphinx
        py
    commands=
        py.test --tb=line -v --junitxml=junit-{envname}.xml check_sphinx.py

2. create a ``doc/check_sphinx.py`` file like this::

    import py
    import subprocess
    def test_linkcheck(tmpdir):
        doctrees = tmpdir.join("doctrees")
        htmldir = tmpdir.join("html")
        subprocess.check_call(
            ["sphinx-build", "-W", "-blinkcheck",
              "-d", str(doctrees), ".", str(htmldir)])
    def test_build_docs(tmpdir):
        doctrees = tmpdir.join("doctrees")
        htmldir = tmpdir.join("html")
        subprocess.check_call([
            "sphinx-build", "-W", "-bhtml",
              "-d", str(doctrees), ".", str(htmldir)])

3. run ``tox -e docs`` and then you may integrate this environment 
   along with your other environments into Hudson. 

Note that ``py.test`` is only installed into the docs environment
and does not need to be in use or installed with any other environment. 

Access package artifacts between Hudson jobs
--------------------------------------------------------

.. _`Hudson Copy Artifact plugin`: http://wiki.hudson-ci.org/display/HUDSON/Copy+Artifact+Plugin

In an extension to :ref:`artifacts` you can configure Hudson jobs to
access each others artifacts.  ``tox`` allows to define 
global variables in a per-hudson context like this:: 

    [tox:hudson]
    distshare=.tox/distshare 

This means that each workspace will have its own ``distshare``
directory and we need to configure some artifact copying. 
The recommend way to do this is to install the `Hudson Copy Artifact plugin`_ 
and for each job which "receives" artifacts you add a **Copy artifacts from another project**
build step using roughly this configuration::

    Project-name: the name of the other (tox-managed) job you want the artifact from
    Artifacts to copy: .tox/dist/*.zip   # where the other jobs creates its artifacts
    Target directory: .tox/distshare     # where we want it to appear for us
    Flatten Directories: CHECK           # copy files flatly, create no subdir-structure

If you add such a build step before your ``tox`` run the latter 
can install the dependency just like :ref:`artifacts` shows it. 
In other words, the only difference in ``tox.ini`` between Hudson 
and non-Hudson artifact sharing is the value for the ``distshare`` 
directory which can be set separately so that the rest of your
``tox.ini`` is fully re-useable and can be debugged on a
developer console. 

.. include:: ../links.txt

Using tox, py.test and the Hudson CI 
-------------------------------------------

The Hudson_ continous integration server allows to define "jobs" with 
"build steps" which can be test invocations.  If you :doc:`install <../install>` ``tox`` on your
default Python installation on each Hudson slave, you can easily create 
a Hudson multi-configuration job that will drive your tox runs from the CI-server side,
using these steps: 

* create a "multi-configuration" job, give it a name of your choice 
* configure your repository so that Hudson can pull it 
* (optional) configure multiple nodes so that tox-runs are performed
  on multiple hosts 
* configure ``axes`` with e.g. using ``ENV`` as an axis name and as values
  the space-separated test environment names you want Hudson/tox to execute
  sequentially. 
* add a Python-build step with this content::

    import tox
    import os
    tox.cmdline(["-e", os.environ['ENV'])

* check ``Publish JUnit test result report`` and enter
  ``**/junit-*.xml`` as the pattern so that Hudson collects 
  test results. 

It makes sense to use something like the following configuration
for your ``commands`` parameter in a ``tox.ini``::

    commands=
        py.test \
            --confcutdir=.. \  # prevent py.test from seeing multiple 
                               # conftest.py files in a nested Hudson workspace
            --junitxml=junit-{envname}.xml

**Note** that we do not use the per-virtualenv ``--basetemp`` setting here because
it can easily lead to too long filenames because Hudson creates a deeply nested
directory structure for the workspaces of the jobs it runs. 

See a real-life example in action with the `py-trunk-multi Hudson job`_

.. _`py-trunk-multi Hudson job`: http://hudson.testrun.org/view/pytest/job/py-trunk-multi/

